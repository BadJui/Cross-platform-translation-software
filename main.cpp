#include <iostream>
#include <windows.h>
#include <bits/stdc++.h>
#include <curl/curl.h>
#include <fstream>
std::string source;
int counter = 0;
// 回调函数，用于接收 HTTP 数据
size_t WriteCallback(void *contents, size_t size, size_t nmemb, std::string *output) {
	size_t totalSize = size * nmemb;
	output->append((char *)contents, totalSize);
	return totalSize;
}
std::string getHttpsPageSource(const std::string &url) {
	CURL *curl;
	CURLcode res;
	std::string response;

	curl_global_init(CURL_GLOBAL_DEFAULT);
	curl = curl_easy_init();
	if (curl) {
		// 设置 URL
		curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

		// 忽略 SSL 证书验证
		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
		curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);

		// 设置数据接收回调函数
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

		// 发送请求
		res = curl_easy_perform(curl);

		// 清理资源
		curl_easy_cleanup(curl);
	}
	curl_global_cleanup();

	return response;
}
std::string GetClipboardText() {
	std::string clipboardText;

	// 打开剪切板
	if (OpenClipboard(NULL)) {
		// 获取剪切板数据句柄
		HANDLE hData = GetClipboardData(CF_TEXT);

		if (hData != NULL) {
			// 锁定剪切板数据，返回数据指针
			char *pszText = static_cast<char *>(GlobalLock(hData));

			if (pszText != NULL) {
				// 将数据拷贝到string对象中
				clipboardText = pszText;

				// 释放锁定的剪切板	数据
				GlobalUnlock(hData);
			}
		}

		// 关闭剪切板
		CloseClipboard();
	}

	return clipboardText;
}
std::string Utf8ToAnsi(std::string utf8Str) {
	int length = MultiByteToWideChar(CP_UTF8, 0, utf8Str.c_str(), -1, nullptr, 0);
	if (length == 0) {
		return "";
	}

	wchar_t *wideStr = new wchar_t[length];
	MultiByteToWideChar(CP_UTF8, 0, utf8Str.c_str(), -1, wideStr, length);

	length = WideCharToMultiByte(CP_ACP, 0, wideStr, -1, nullptr, 0, nullptr, nullptr);
	if (length == 0) {
		delete[] wideStr;
		return "";
	}

	char *ansiStr = new char[length];
	WideCharToMultiByte(CP_ACP, 0, wideStr, -1, ansiStr, length, nullptr, nullptr);

	std::string result(ansiStr);

	delete[] wideStr;
	delete[] ansiStr;

	return result;
}
std::string ConvertANSIToUTF8(const std::string &str) {
	int wideLength = MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, nullptr, 0);
	if (wideLength == 0) {
		// 转换失败，返回空字符串或者抛出异常
		return "";
	}

	wchar_t *wideBuffer = new wchar_t[wideLength];
	MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, wideBuffer, wideLength);

	int utf8Length = WideCharToMultiByte(CP_UTF8, 0, wideBuffer, -1, nullptr, 0, nullptr, nullptr);
	if (utf8Length == 0) {
		// 转换失败，释放内存并返回空字符串或者抛出异常
		delete[] wideBuffer;
		return "";
	}

	char *utf8Buffer = new char[utf8Length];
	WideCharToMultiByte(CP_UTF8, 0, wideBuffer, -1, utf8Buffer, utf8Length, nullptr, nullptr);

	std::string utf8String(utf8Buffer);

	delete[] wideBuffer;
	delete[] utf8Buffer;

	return utf8String;
}
std::string urlEncode(const std::string &input) {
	std::ostringstream encoded;
	encoded.fill('0');
	encoded << std::hex;

	for (char c : input) {
		// 保留字母、数字和部分特殊字符不进行编码
		if (isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') {
			encoded << c;
		} else {
			// 对其他字符进行 URL 编码
			encoded << '%' << std::setw(2) << int(static_cast<unsigned char>(c));
		}
	}

	return encoded.str();
}
std::string convert(std::string input) {
	return urlEncode(ConvertANSIToUTF8(input));
}
void Trans_Saver(std::string trans) {
	std::string s1="\x3c\x21\x44\x4f\x43\x54\x59\x50\x45\x20\x68\x74\x6d\x6c\x3e\x0a\x3c\x68\x74\x6d\x6c\x3e\x0a\x3c\x6d\x65\x74\x61\x20\x63\x68\x61\x72\x73\x65\x74\x3d\x22\x55\x54\x46\x2d\x38\x22\x3e\x0a\x3c\x68\x65\x61\x64\x3e\x0a\x20\x20\x20\x20\x3c\x73\x74\x79\x6c\x65\x3e\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x62\x6f\x64\x79\x20\x7b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x6d\x61\x72\x67\x69\x6e\x3a\x20\x30\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x70\x61\x64\x64\x69\x6e\x67\x3a\x20\x30\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x62\x61\x63\x6b\x67\x72\x6f\x75\x6e\x64\x2d\x63\x6f\x6c\x6f\x72\x3a\x20\x62\x6c\x61\x63\x6b\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x64\x69\x73\x70\x6c\x61\x79\x3a\x20\x66\x6c\x65\x78\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x61\x6c\x69\x67\x6e\x2d\x69\x74\x65\x6d\x73\x3a\x20\x63\x65\x6e\x74\x65\x72\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x6a\x75\x73\x74\x69\x66\x79\x2d\x63\x6f\x6e\x74\x65\x6e\x74\x3a\x20\x63\x65\x6e\x74\x65\x72\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x68\x65\x69\x67\x68\x74\x3a\x20\x31\x30\x30\x76\x68\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x66\x6f\x6e\x74\x2d\x73\x69\x7a\x65\x3a\x20\x31\x30\x76\x77\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x63\x6f\x6c\x6f\x72\x3a\x20\x77\x68\x69\x74\x65\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x74\x65\x78\x74\x2d\x61\x6c\x69\x67\x6e\x3a\x20\x63\x65\x6e\x74\x65\x72\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x7d\x0a\x20\x20\x20\x20\x3c\x2f\x73\x74\x79\x6c\x65\x3e\x0a\x3c\x2f\x68\x65\x61\x64\x3e\x0a\x3c\x62\x6f\x64\x79\x3e\x0a\x20\x20\x20\x20\x3c\x64\x69\x76\x3e";
	std::string s2="\x3c\x2f\x64\x69\x76\x3e\x0a\x3c\x2f\x62\x6f\x64\x79\x3e\x0a\x3c\x2f\x68\x74\x6d\x6c\x3e\x0a";
	std::ofstream html_ofile("Trans.html");
	html_ofile<<ConvertANSIToUTF8(s1+trans+s2);
	html_ofile.close();
}

LRESULT CALLBACK KeyboardHook(int nCode, WPARAM wParam, LPARAM lParam) {
	if (nCode == HC_ACTION) {
		PKBDLLHOOKSTRUCT p = (PKBDLLHOOKSTRUCT)lParam;
		if (wParam == WM_KEYDOWN && p->vkCode == 'C') {
			if (GetAsyncKeyState(VK_CONTROL) & 0x8000) {
				counter++;
				if (counter == 3) {
					std::cout << "[+] 欲翻译文本截取成功：" << GetClipboardText() << std::endl;
					source = getHttpsPageSource("https://api.pearktrue.cn/api/googletranslate/?text="+convert(GetClipboardText())+"&type=auto");
					source = Utf8ToAnsi(source);
					if(source.find("text")!=std::string::npos) {
						source = source.substr(source.find("result")+10,source.find("api_source")-8-source.find("result")-10);
						std::cout << "[+] 翻译结果为：" << source << std::endl;
						Trans_Saver(source);
					}
					counter = 0;  // 重置计数器
				}
			}
		}
	}
	return CallNextHookEx(NULL, nCode, wParam, lParam);
}

std::string getIP() {
	WSADATA WSAData;
	char hostName[256];
	if (!WSAStartup(MAKEWORD(2, 0),&WSAData)) {
		if(!gethostname(hostName,sizeof(hostName))) {
			hostent *host=gethostbyname(hostName);
			if(host!=NULL) {
				return inet_ntoa(*(struct in_addr*)*host->h_addr_list);
			}
		}
	}
	return "Get IP failed.";
}
std::string Local_Port;
void Start_Process() { //初始化Index.html的代码
	std::ofstream ofile("index.html");
	ofile<<"\x3c\x21\x44\x4f\x43\x54\x59\x50\x45\x20\x68\x74\x6d\x6c\x3e\x0a\x3c\x68\x74\x6d\x6c\x3e\x0a\x3c\x6d\x65\x74\x61\x20\x63\x68\x61\x72\x73\x65\x74\x3d\x22\x55\x54\x46\x2d\x38\x22\x3e\x0a\x3c\x68\x65\x61\x64\x3e\x0a\x20\x20\x20\x20\x3c\x73\x74\x79\x6c\x65\x3e\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x23\x66\x75\x6c\x6c\x73\x63\x72\x65\x65\x6e\x2d\x69\x66\x72\x61\x6d\x65\x20\x7b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x70\x6f\x73\x69\x74\x69\x6f\x6e\x3a\x20\x66\x69\x78\x65\x64\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x74\x6f\x70\x3a\x20\x30\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x6c\x65\x66\x74\x3a\x20\x30\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x77\x69\x64\x74\x68\x3a\x20\x31\x30\x30\x25\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x68\x65\x69\x67\x68\x74\x3a\x20\x31\x30\x30\x25\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x62\x6f\x72\x64\x65\x72\x3a\x20\x6e\x6f\x6e\x65\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x7d\x0a\x20\x20\x20\x20\x3c\x2f\x73\x74\x79\x6c\x65\x3e\x0a\x3c\x2f\x68\x65\x61\x64\x3e\x0a\x3c\x62\x6f\x64\x79\x3e\x0a\x20\x20\x20\x20\x3c\x69\x66\x72\x61\x6d\x65\x20\x69\x64\x3d\x22\x66\x75\x6c\x6c\x73\x63\x72\x65\x65\x6e\x2d\x69\x66\x72\x61\x6d\x65\x22\x20\x73\x72\x63\x3d\x22\x68\x74\x74\x70\x3a\x2f\x2f";
	ofile<<getIP()<<":"<<Local_Port;
	ofile<<"\x2f\x54\x72\x61\x6e\x73\x2e\x68\x74\x6d\x6c\x22\x3e\x3c\x2f\x69\x66\x72\x61\x6d\x65\x3e\x0a\x0a\x20\x20\x20\x20\x3c\x73\x63\x72\x69\x70\x74\x3e\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x76\x61\x72\x20\x70\x72\x65\x76\x69\x6f\x75\x73\x53\x6f\x75\x72\x63\x65\x43\x6f\x64\x65\x20\x3d\x20\x22\x22\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x73\x65\x74\x49\x6e\x74\x65\x72\x76\x61\x6c\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x29\x20\x7b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x66\x65\x74\x63\x68\x28\x27\x68\x74\x74\x70\x3a\x2f\x2f";
	ofile<<getIP()<<":"<<Local_Port;
	ofile<<"\x2f\x54\x72\x61\x6e\x73\x2e\x68\x74\x6d\x6c\x27\x29\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x2e\x74\x68\x65\x6e\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x72\x65\x73\x70\x6f\x6e\x73\x65\x29\x20\x7b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x72\x65\x74\x75\x72\x6e\x20\x72\x65\x73\x70\x6f\x6e\x73\x65\x2e\x74\x65\x78\x74\x28\x29\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x7d\x29\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x2e\x74\x68\x65\x6e\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x64\x61\x74\x61\x29\x20\x7b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x69\x66\x20\x28\x64\x61\x74\x61\x20\x21\x3d\x3d\x20\x70\x72\x65\x76\x69\x6f\x75\x73\x53\x6f\x75\x72\x63\x65\x43\x6f\x64\x65\x29\x20\x7b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x70\x72\x65\x76\x69\x6f\x75\x73\x53\x6f\x75\x72\x63\x65\x43\x6f\x64\x65\x20\x3d\x20\x64\x61\x74\x61\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x72\x65\x66\x72\x65\x73\x68\x49\x66\x72\x61\x6d\x65\x28\x64\x61\x74\x61\x29\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x7d\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x7d\x29\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x2e\x63\x61\x74\x63\x68\x28\x66\x75\x6e\x63\x74\x69\x6f\x6e\x28\x65\x72\x72\x6f\x72\x29\x20\x7b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x63\x6f\x6e\x73\x6f\x6c\x65\x2e\x6c\x6f\x67\x28\x27\x45\x72\x72\x6f\x72\x3a\x27\x2c\x20\x65\x72\x72\x6f\x72\x29\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x7d\x29\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x7d\x2c\x20\x35\x30\x30\x29\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x72\x65\x66\x72\x65\x73\x68\x49\x66\x72\x61\x6d\x65\x28\x73\x6f\x75\x72\x63\x65\x43\x6f\x64\x65\x29\x20\x7b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x76\x61\x72\x20\x69\x66\x72\x61\x6d\x65\x20\x3d\x20\x64\x6f\x63\x75\x6d\x65\x6e\x74\x2e\x67\x65\x74\x45\x6c\x65\x6d\x65\x6e\x74\x42\x79\x49\x64\x28\x27\x66\x75\x6c\x6c\x73\x63\x72\x65\x65\x6e\x2d\x69\x66\x72\x61\x6d\x65\x27\x29\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x69\x66\x72\x61\x6d\x65\x2e\x73\x72\x63\x64\x6f\x63\x20\x3d\x20\x73\x6f\x75\x72\x63\x65\x43\x6f\x64\x65\x3b\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x7d\x0a\x20\x20\x20\x20\x3c\x2f\x73\x63\x72\x69\x70\x74\x3e\x0a\x3c\x2f\x62\x6f\x64\x79\x3e\x0a\x3c\x2f\x68\x74\x6d\x6c\x3e\x0a";
}
int main(int argc,char *argv[]) {
	if(argc==1) {
		std::cout<<"请输入端口！\n";
		return 1;
	}
	Local_Port=argv[1];
	Start_Process();
	system(("start python -m http.server "+Local_Port).c_str());
	std::cout<<"请用手机或其他设备访问["<<getIP()<<":"<<Local_Port<<"]，然后在电脑选中一段文本按三次[Ctrl+C]即可在其他设备上显示翻译！\n";


	HHOOK keyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardHook, NULL, 0);

	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	UnhookWindowsHookEx(keyboardHook);
	return 0;
}

